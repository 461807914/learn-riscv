# 一、 CPU架构

## 1.1 概述

**指令集**：处理器进行操作的最小单元。

**微架构**：处理器具体硬件实现方案。

指令集架构是硬件与软件的桥梁，**也是区分不同CPU的主要标准，比如x86**指令集架构包括：

1. 数据类型
2. 存储模型
3. 软件可见状态（通用寄存器，程序计数器，处理器状态）
4. 指令集（指令类型与编码，寻址模式，数据结构）
5. 系统模型（状态，特权级别，中断和异常）
6. 外部接口（输入输出接口，管理）



### 1.1.1 CISC与RISC

CISC指令数量较多，包括较多不常用的特殊指令。RISC只包含常用指令，不常用的指令通过执行多条常用指令达到效果。

**指令集架构位数**：指通用寄存器的宽度，决定了寻址范围大小和数据运算能力的强弱。

32位架构处理器，通用寄存器宽度为32，寻址范围$2^{32}$，运算指令可以操作的位数为32.

指令集架构的宽度和指令的编码长度无任何关系。即，不是说64位架构的指令长度位64位，理论上来说，指令编码长度越短越好，可以节省代码存储空间。

常见架构位数位8，16，32，64



### 1.1.2 架构代表

**x86**，intel推出的复杂指令集，AMD的cpu也是x86架构。x86架构是具有代表性的可变指令长度的CISC架构。

**微码化**，将复杂的CISC指令先用硬件解码器翻译成对应的内部简单指令（微码）序列，然后送给处理器的流水线执行。x86使用这种技巧克服了CISC的部分缺点，使其称为一种RISC形式。但是会有一定的开销。



**SPARC**，sun公司的指令集架构，是一种RISC架构，面向服务器领域涉及，有72到640多个通用寄存器，64个一组。后来无了=_=



**MIPS**，一种简洁优化的RISC架构，最经典的RISC架构。路由器，游戏机上用的多。



**POWER**，IBM的RISC架构，主要用在服务器上。



**Alpha**，一种64位的RISC架构，DEC公司开发的。



**ARM**，没啥好说的，后面都是在说它。



**ARC**，Synopsys公司的32位RISC的IP。



## 1.2 ARM

全称为 advanced RISC Machines

Cortex-A：面向性能密集型系统处理器核心。

Cortex-R：面向实时应用的高性能核。

Cortex-M：面向嵌入式。



# 二、RISC-V 架构

注意，RISC表示精简指令集；RISC-V为伯克利发明的特定指令集架构（属于RISC类型）

RISC-V是一个模块化架构，这是x86与ARM架构不具备的。

模块化的RISC-V架构能够选择不同模块进行组合，满足不同应用场景。

基本的RISC-V指令数有40多条，加上其它模块化指令共几十条。



## 2. 1 模块化指令子集

RISC-V 指令集使用模块化组织，每个模块使用一个英文字母表示。RISC-V 强制要求实现的指令集部分由字母I表示的基本整数指令子集。使用该整数指令子集，能完整实现软件编译。

RISC-V 的模块化指令集如下

| 基本指令集 | 指令数 |                      描述                       |
| :--------: | :----: | :---------------------------------------------: |
|   RV32I    |   47   | 32位地址空间与整数指令，支持32个通用整数寄存器  |
|   RV32E    |   47   |       RV32I的子集，支持16个通用整数寄存器       |
|   RV64I    |   59   |    64位地址空间与整数指令及一部分的整数指令     |
|   RV128I   |   71   | 128位地址空间与整数指令及一部分64位和32位的指令 |



| 扩展指令集 | 指令数 |                          描述                           |
| :--------: | :----: | :-----------------------------------------------------: |
|     M      |   8    |                   整数乘法与除法指令                    |
|     A      |   11   | 存储器原子操作指令和Load-Reserved/Store-Conditional指令 |
|     F      |   26   |                单精度（32比特）浮点指令                 |
|     D      |   26   |       双精度（64比特）浮点指令，必须支持F扩展指令       |
|     C      |   46   |                压缩指令，指令长度为16位                 |

以上称为通用组合，用字母G表示，因此RV32G表示RV32IMAFDC，同理RV64G表示RV64IMAFD。

### 2.1.1 指令编码
处理器希望能快速读取通用寄存器组，用于提高处理器性能和优化。多数商用RISC架构由于不断
添加新指令，导致寄存器索引位置非常混乱，给译码造成负担，使得性能下降。
RISC-V使用的通用寄存器的索引放在固定位置，因此指令译码速度快。



### 2.1.2 访存指令
RISC-V使用Load和Store指令访存，其它指令无法访存。硬件设计更加简单。访存的基本单位是byte，支持一个字节、半个字、一个字为单位的读写，64位还可以双字读写。
RISC-V有如下特点：
1. 为了提高存储器读写性能，RISC-V推荐使用地址对齐的读写，也支持非对齐的读写，软硬件都支持。
2. RISC-V仅支持小端格式。
3. 不支持地址自增自减的模式（这种模式可以提高访问连续地址的性能，但是增加处理器设计难度）。
4. 使用松散存储器模型，对于访问不同地址的存储器读写指令的执行顺序不做要求。除非明确使用
存储器凭证（Fence）指令进行屏蔽。

### 2.1.3 跳转指令
两条无条件跳转指令`jal`指令与`jalr`指令。

`jal`为jump and link（跳转链接）用于子程序调用，并将子程序返回地址存在链接寄存器（link register，由某个通用整数寄存器担任）。

`jalr`为jump and link-register（跳转链接寄存器）用于子程序返回指令，通过将`jal`指令
保存的链接寄存器用于`jalr`指令的基地址寄存器，则可以从子程序返回。

六条有条件跳转指令，使用两个整数操作进行比较。如果比较条件满足，则跳转。此类指令将比较与跳转两个操作放在一条指令中完成。

其它的RISC架构是用两条独立的指令，一条用于比较指令，结果保存到状态寄存器中；第二条指令用于根据状态寄存器的值进行跳转。


对于没有分支预测的低端CPU，RISC-V要求采用默认的静态分支预测机制：
如果是向后跳转的条件跳转指令（这里“向后”应该是指指令顺序执行），预测为“跳”；
如果是向前跳转，预测为“不跳”；
依据以上机制生成汇编代码，提高性能。


为了提高性能，所有条件跳转指令跳转目标的便宜了（相对于当前指令的地址）都是有符号数。
其符号编码在固定位置，这种静态预测机制在硬件实现容易，方便译码。
比如，如果该有符号数位1，则表示负数，跳转的目标地址位当前地址减去偏移量，即向后跳转。

### 2.1.4 子程序调用

RISC架构中调用子程序的过程为：
1. 进入子函数后需要用存储器写指令（store）保存环境上下文（通用寄存器的值等）保存到系统存储器的堆栈当中。
2. 子程序推出后，调用load指令将环境上下文信息从系统堆栈中读出来，称为恢复现场。

现场恢复的过程在如C/C++的高层次语言当中有编译器生成指令，体现在汇编指令当中，需要消耗CPU时间来处理。

在部分RISC中，保存现场和恢复现场得到加速处理，部分RISC架构可以一次写多个寄存器到存储器当中（Store Multiple），也可以一次从存储器中读多个寄存器中的指令。
即一条指令完成多个寄存器到存储器中的读写操作，减少汇编代码。缺点是会使CPU的硬件设计更加复杂，增加硬件开销，损伤时许，使CPU主频无法提高。

RISC-V中没有使用“一次读写多个寄存器的指令”，如果有介意“保存现场”和“恢复现场”的指令条数，有专用程序库用于进行现场的恢复和保存。

### 2.2.7 无条件码执行

早期RISC架构的指令头几位是条件码（Conditional Code），当条件吗为真时，该指令执行。这样的作法可以使编译器将循环指令编译成带条件码的指令，而不用编译成分支跳转指令。
这样做可以减少分支跳转和指令条数，也避免了分支跳转带来的性能损失。缺点是硬件设计复杂，主频降低。

RISCV没有使用条件码，对于任何判断都使用普通条件分支跳转。

### 2.2.8 无分支延迟槽

早期RISC使用分支延迟槽(Delay slot)，具有代表性的是MIPS架构。分支延迟槽就是在每一条分支指令后面紧跟一条或若干条指令不受分支跳转影响,不管分支是否跳转，后面的这几条指令都一定会被执行。早期使用分支延迟槽是因为处理器的流水线比较简单，没有使用高级硬件动态分支预测器，使用分支延迟早能够取得较好性能，但是使CPU设计更复杂。
RISC-V没有使用分支延迟槽，


### 2.2.9 零开销硬件循环
零开销硬件循环（zero overhead hardware loop)指令，使用硬件直接设置某些循环次数寄存器，使程序自动进行循环，每一次循环，寄存器自动减1，直到寄存器为0。这样做使因为在代码中
`for (int i=0;i<n;i++)`这样的代码很常见，用来优化编译指令。

在RISC-V里面为了减少硬件设计复杂度，没有使用这样的设计。

### 2.2.10 简洁的运算指令

支持基本数据类型的加减乘除等运算，RISC-V有一个特别的地方就是对任何运算指令错误（除零、溢出等等），不产生异常，而是产生一个特殊的默认值，同时设置某些状态寄存器的状态位。

### 2.2.11 压缩指令集

RISC-V的整数指令集长度为32位，等长的指令定义使得仅支持整数指令自己的基本RISC-V CPU很容易设计，但是等长的编码指令也会造成代码体积较大的问题。
为了满足嵌入式等领域，RISC-V使用了一种可选的压缩（Compressed）指令集，用字母C或RVC表示。16位长指令与普通的32位长指令可以自由交织。

RISC-V中的16位指令的压缩策略是将一部分最常用的32位指令中的信息进行压缩重拍列得到（例如有一个指令使用了两个相同的操作数索引，则可以省略一个），因此每个16位指令都能找到一一对应的原始32位指令。简化编译器工具链的负担。

### 2.2.12 特权模式

RISC-V有三种工作模式：
1. 机器模式，简称M Model
2. 监督模式，简称S Model
3. 用户模式，简称U Model

M Model为必选模式，其余两种可选，通过不同模式组合实现不同的系统。
RISC-V架构也支持几种不同的存储器地址管理机制支持几种不同的存储器地址管理机制，包括物理地址和虚拟地址的管理机制，使得RISC-V架构可以支持从简单的嵌入式系统（直接操作物理地址）到复杂的操作胸痛（直接操作虚拟地址）。

### 2.2.13 CSR寄存器
全称是控制和状态寄存器，用于配置或记录一些运行的状态。CSR寄存器是处理器核内部寄存器，使用自己的地址编码空间和存储器寻址的地址区间没有关系。CSR寄存器使用专用的CSR指令，包括CSRRW、
CSRRS等。

### 2.2.14 中断和异常
中断和异常机制是处理器指令集架构中的核心，RISC-V中由一套简单的基本中断和异常机制，也允许用户对其进行定制和扩展。

### 2.2.15 矢量指令集
RISC-V目前没有定型的矢量指令子集，后面设计了一个很先进的可变长度的矢量，而不是定长的SIMD指令集（ARM的NEON和Intel的MMX），从而能够灵活的支持不同实现，还可以保证功耗和性能。

### 2.2.16 自定制指令扩展
RISC-V架构有一个很重要的特性，即支持第三方扩展。用户可以扩展自己的指令子集，RISC-V预留了大量的指令编码空间用于用户自定义扩展，定义了4条Custom指令可以供用户直接使用，每条Custom指令都预留了几个比特位的子编码空间，用户可以使用4条Custom指令扩展出几十条自定义指令。

### 2.2.17 总结与比较
RISC-V追求高效、简单、低功耗与低面积

## 2.4 关于RISC的开放架构

OpenRISC、RISC-V，SPARC

