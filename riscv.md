# 一、 CPU架构

## 1.1 概述

**指令集**：处理器进行操作的最小单元。

**微架构**：处理器具体硬件实现方案。

指令集架构是硬件与软件的桥梁，**也是区分不同CPU的主要标准，比如x86**指令集架构包括：

1. 数据类型
2. 存储模型
3. 软件可见状态（通用寄存器，程序计数器，处理器状态）
4. 指令集（指令类型与编码，寻址模式，数据结构）
5. 系统模型（状态，特权级别，中断和异常）
6. 外部接口（输入输出接口，管理）



### 1.1.1 CISC与RISC

CISC指令数量较多，包括较多不常用的特殊指令。RISC只包含常用指令，不常用的指令通过执行多条常用指令达到效果。

**指令集架构位数**：指通用寄存器的宽度，决定了寻址范围大小和数据运算能力的强弱。

32位架构处理器，通用寄存器宽度为32，寻址范围$2^{32}$，运算指令可以操作的位数为32.

指令集架构的宽度和指令的编码长度无任何关系。即，不是说64位架构的指令长度位64位，理论上来说，指令编码长度越短越好，可以节省代码存储空间。

常见架构位数位8，16，32，64



### 1.1.2 架构代表

**x86**，intel推出的复杂指令集，AMD的cpu也是x86架构。x86架构是具有代表性的可变指令长度的CISC架构。

**微码化**，将复杂的CISC指令先用硬件解码器翻译成对应的内部简单指令（微码）序列，然后送给处理器的流水线执行。x86使用这种技巧克服了CISC的部分缺点，使其称为一种RISC形式。但是会有一定的开销。



**SPARC**，sun公司的指令集架构，是一种RISC架构，面向服务器领域涉及，有72到640多个通用寄存器，64个一组。后来无了=_=



**MIPS**，一种简洁优化的RISC架构，最经典的RISC架构。路由器，游戏机上用的多。



**POWER**，IBM的RISC架构，主要用在服务器上。



**Alpha**，一种64位的RISC架构，DEC公司开发的。



**ARM**，没啥好说的，后面都是在说它。



**ARC**，Synopsys公司的32位RISC的IP。



## 1.2 ARM

全称为 advanced RISC Machines

Cortex-A：面向性能密集型系统处理器核心。

Cortex-R：面向实时应用的高性能核。

Cortex-M：面向嵌入式。



# 二、RISC-V 架构

注意，RISC表示精简指令集；RISC-V为伯克利发明的特定指令集架构（属于RISC类型）

RISC-V是一个模块化架构，这是x86与ARM架构不具备的。

模块化的RISC-V架构能够选择不同模块进行组合，满足不同应用场景。

基本的RISC-V指令数有40多条，加上其它模块化指令共几十条。



## 2. 1 模块化指令子集

RISC-V 指令集使用模块化组织，每个模块使用一个英文字母表示。RISC-V 强制要求实现的指令集部分由字母I表示的基本整数指令子集。使用该整数指令子集，能完整实现软件编译。

RISC-V 的模块化指令集如下

| 基本指令集 | 指令数 |                      描述                       |
| :--------: | :----: | :---------------------------------------------: |
|   RV32I    |   47   | 32位地址空间与整数指令，支持32个通用整数寄存器  |
|   RV32E    |   47   |       RV32I的子集，支持16个通用整数寄存器       |
|   RV64I    |   59   |    64位地址空间与整数指令及一部分的整数指令     |
|   RV128I   |   71   | 128位地址空间与整数指令及一部分64位和32位的指令 |



| 扩展指令集 | 指令数 |                          描述                           |
| :--------: | :----: | :-----------------------------------------------------: |
|     M      |   8    |                   整数乘法与除法指令                    |
|     A      |   11   | 存储器原子操作指令和Load-Reserved/Store-Conditional指令 |
|     F      |   26   |                单精度（32比特）浮点指令                 |
|     D      |   26   |       双精度（64比特）浮点指令，必须支持F扩展指令       |
|     C      |   46   |                压缩指令，指令长度为16位                 |

以上称为通用组合，用字母G表示，因此RV32G表示RV32IMAFDC，同理RV64G表示RV64IMAFD。

### 2.1.1 指令编码
处理器希望能快速读取通用寄存器组，用于提高处理器性能和优化。多数商用RISC架构由于不断
添加新指令，导致寄存器索引位置非常混乱，给译码造成负担，使得性能下降。
RISC-V使用的通用寄存器的索引放在固定位置，因此指令译码速度快。



### 2.1.2 访存指令
RISC-V使用Load和Store指令访存，其它指令无法访存。硬件设计更加简单。访存的基本单位是byte，支持一个字节、半个字、一个字为单位的读写，64位还可以双字读写。
RISC-V有如下特点：
1. 为了提高存储器读写性能，RISC-V推荐使用地址对齐的读写，也支持非对齐的读写，软硬件都支持。
2. RISC-V仅支持小端格式。
3. 不支持地址自增自减的模式（这种模式可以提高访问连续地址的性能，但是增加处理器设计难度）。
4. 使用松散存储器模型，对于访问不同地址的存储器读写指令的执行顺序不做要求。除非明确使用
存储器凭证（Fence）指令进行屏蔽。

### 2.1.3 跳转指令
两条无条件跳转指令`jal`指令与`jalr`指令。

`jal`为jump and link（跳转链接）用于子程序调用，并将子程序返回地址存在链接寄存器（link register，由某个通用整数寄存器担任）。

`jalr`为jump and link-register（跳转链接寄存器）用于子程序返回指令，通过将`jal`指令
保存的链接寄存器用于`jalr`指令的基地址寄存器，则可以从子程序返回。

六条有条件跳转指令，使用两个整数操作进行比较。如果比较条件满足，则跳转。此类指令将比较与跳转两个操作放在一条指令中完成。

其它的RISC架构是用两条独立的指令，一条用于比较指令，结果保存到状态寄存器中；第二条指令用于根据状态寄存器的值进行跳转。


对于没有分支预测的低端CPU，RISC-V要求采用默认的静态分支预测机制：
如果是向后跳转的条件跳转指令（这里“向后”应该是指指令顺序执行），预测为“跳”；
如果是向前跳转，预测为“不跳”；
依据以上机制生成汇编代码，提高性能。


为了提高性能，所有条件跳转指令跳转目标的便宜了（相对于当前指令的地址）都是有符号数。
其符号编码在固定位置，这种静态预测机制在硬件实现容易，方便译码。
比如，如果该有符号数位1，则表示负数，跳转的目标地址位当前地址减去偏移量，即向后跳转。

### 2.1.4 子程序调用

RISC架构中调用子程序的过程为：
1. 进入子函数后需要用存储器写指令（store）保存环境上下文（通用寄存器的值等）保存到系统存储器的堆栈当中。
2. 子程序推出后，调用load指令将环境上下文信息从系统堆栈中读出来，称为恢复现场。

现场恢复的过程在如C/C++的高层次语言当中有编译器生成指令，体现在汇编指令当中，需要消耗CPU时间来处理。

在部分RISC中，保存现场和恢复现场得到加速处理，部分RISC架构可以一次写多个寄存器到存储器当中（Store Multiple），也可以一次从存储器中读多个寄存器中的指令。
即一条指令完成多个寄存器到存储器中的读写操作，减少汇编代码。缺点是会使CPU的硬件设计更加复杂，增加硬件开销，损伤时许，使CPU主频无法提高。

RISC-V中没有使用“一次读写多个寄存器的指令”，如果有介意“保存现场”和“恢复现场”的指令条数，有专用程序库用于进行现场的恢复和保存。

### 2.2.7 无条件码执行

早期RISC架构的指令头几位是条件码（Conditional Code），当条件吗为真时，该指令执行。这样的作法可以使编译器将循环指令编译成带条件码的指令，而不用编译成分支跳转指令。
这样做可以减少分支跳转和指令条数，也避免了分支跳转带来的性能损失。缺点是硬件设计复杂，主频降低。

RISCV没有使用条件码，对于任何判断都使用普通条件分支跳转。

### 2.2.8 无分支延迟槽

早期RISC使用分支延迟槽(Delay slot)，具有代表性的是MIPS架构。分支延迟槽就是在每一条分支指令后面紧跟一条或若干条指令不受分支跳转影响。